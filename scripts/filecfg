#!/bin/bash
#  _____ ___ _     _____ ____ _____ ____ 
# |  ___|_ _| |   | ____/ ___|  ___/ ___|
# | |_   | || |   |  _|| |   | |_ | |  _ 
# |  _|  | || |___| |__| |___|  _|| |_| |
# |_|   |___|_____|_____\____|_|   \____|
#
# by DRAGONO

# filecfg is a command to manipulate text file.

show_help()
{
    echo "Usage: $0 [file] [option]"
    echo ""
    echo "Options:"
    echo "  --search-string {string}							Search for a corresponding string in a file."
    echo "  --search-line {string}							Search for a corresponding string in a file. The string need to be a whole line."
    echo "  --replace-string {original-string} {new-string}				Search for a corresponding string and replace it."
    echo "  --get-option {option} {delimiter} 						Look for something like : option[DELIMITER]value and return the value where option and delimiter match."
    echo "  --set-option {option} {delimiter} {value}					Look for something like : option[DELIMITER]value and replace value with the new value."
    echo "  --get-option-multiple {options} {del1} {del2}                               Look for opt1[del1]opt2[del1]...[del1]optn[del2]val1[del1]val2[del1]...[del1]valn and will return the according value"
    echo "  --set-option-multiple {set of option} {option} {del1} {del2} {value}        Basically --set-option + --get-option-multiple. set of option is a string of options to match (ex: opt1,opt2,opt3, useful in case you may also have opt1,opt2 in the same file!), option is the option you want to edit."
    echo "  --get-option-all {options} {del1} {del2}                                    Return a list like option1=value1 ... optionN=valueN"
    echo "  -h, --help      					                        Show help."
}




search_string()
{
    local file="$1"
    local str="$2"

    grep "$str" $file > /dev/null
    if [ $? -eq 0 ]
    then
	echo "true"
    else
	echo "false"
    fi
}

search_line()
{
    local file="$1"
    local str="$2"

    grep -x "$str" $file > /dev/null
    if [ $? -eq 0 ]
    then
	echo "true"
    else
	echo "false"
    fi
}

replace_string()
{
    local file="$1"
    local str1="$2"
    local str2="$3"

    exist=`search_string $file $str1`
    if [ "$exist" = "true" ]
    then
	sed -i "s/${str1}/${str2}/g" $file
    else
	echo "[ERROR]: Could not find pattern $str1 in file $file."
	exit 1
    fi
}

get_option()
{
    local file="$1"
    local option="$2"
    local delim="$3"

    line=`grep "^${option}${delim}" $file`

    if [ $? -eq 0 ]
    then
        value=`echo $line | sed "s/^${option}${delim}//"`
        echo $value
    else
	echo "[ERROR]: Could not find option $option in file $file."
	exit 1
    fi
}

set_option()
{
    local file="$1"
    local option="$2"
    local delim="$3"
    local value="$4"

    grep "^${option}${delim}" $file > /dev/null

    if [ $? -eq 0 ]
    then
	    sed -i "s/^\(${option}${delim}\).*/\1${value}/" $file	
    else
	echo "[ERROR]: Could not find option $option in file $file."
	exit 1
    fi
}

get_option_multiple()
{
    local file="$1"
    local option="$2"
    local del1="$3"
    local del2="$4"

    line=`grep ".*${option}.*${del2}.*" $file`
    if [ $? -eq 0 ]
    then
        # We count which option number is it in order to retreive value number
        options=`echo $line | cut -d${del2} -f1 | sed "s/${del1}/ /g"`
        values=`echo $line | cut -d${del2} -f2 | sed "s/${del1}/ /g"`

	nmbr=1
	for opt in $options
	do
	    if [ "$opt" = "$option" ]
            then
		break;
	   else
		nmbr=$(($nmbr+1))
	    fi
	done

	# Now that we know which option number it is, we return the value number
	echo $values | sed "s/ /${del1}/g" | cut -d${del1} -f${nmbr}
    else
        echo "[ERROR]: Could not find option $option in file $file."
	exit 1
    fi
}

set_option_multiple()
{
    local file="$1"
    local setOfOpt="$2"
    local option="$3"
    local del1="$4"
    local del2="$5"
    local value="$6"

    line=`grep "^${setOfOpt}${del2}.*" $file`
    if [ $? -eq 0 ]
    then
	# 1 - Getting option number
        options=`echo $line | cut -d${del2} -f1 | sed "s/${del1}/ /g"`
        values=`echo $line | cut -d${del2} -f2 | sed "s/${del1}/ /g"`

	nmbr=1
	for opt in $options
	do
	   if [ "$opt" = "$option" ]
            then
		break;
	  else
		nmbr=$(($nmbr+1))
	   fi
	done

	# 2 - Rebuilding the whole line --- which will replace the current line in the file
	newline=$setOfOpt${del2} # Options + delimiter2
	cpt=1
	for val in $values
	do
	    if (( $nmbr == $cpt ))
	    then
		newline=$newline$value$del1
		cpt=$(($cpt+1))
	    else
		newline=$newline$val$del1
		cpt=$(($cpt+1))
	    fi
	done
	# Removing extra del2
	newline=`echo $newline | sed "s/\(.*\)${del1}$/\1/"`
	echo newline: $newline

	# 3 - Replacing old line with the new one
	sed -i "s/^${setOfOpt}${del2}.*$/${newline}/" $file
    else
	echo "[ERROR]: Could not find option $setOfOpt in $file."
	exit 1
    fi
}

get_option_all()
{
    local file="$1"
    local setOfOpt="$2"
    local del1="$3"
    local del2="$4"

    line=`grep "^$setOfOpt$del2.*" $file`

    if [ ! $line = "" ]
    then
        options=`echo $line | sed "s/${del2}.*//g"`
        values=`echo $line | sed "s/.*${del2}//g"`
	nmbr=`echo $options | sed "s/${del1}/ /g" | wc -w`

	for((i=1;i<=nmbr;i++))
	do
            currentOpt=`echo $options | cut -d${del1} -f${i}`
	    currentVal=`echo $values | cut -d${del1} -f${i}`
            echo $currentOpt=$currentVal 
        done
    else
        echo "[ERROR]: Could not find option $setOfOpt in $file."
	exit 1	    
    fi
}

# === Reading Arguments ===
# Need at least three arguments (file, option, string)
if [ $# -lt 3 ]
then
    show_help
    exit 1
fi

# Does the file exist
if [ ! -f $1 ]
then
    echo "[FATAL]: $1 does not exist or isn't a file."
    exit 1
fi

file=$1
shift 1

# Else we can start reading args
while [ $# -gt 0 ]
do
    case $1 in

        --search-string)
	    if test $# -lt 2; then echo "[ERROR]: --search-string: not enough arguments."; show_help; exit 1; fi;
            search_string $file $2
	    shift 2	    
        ;;

        --search-line)
	    if test $# -lt 2; then echo "[ERROR]: --search-line: not enough arguments."; show_help; exit 1; fi;    
            search_line $file $2
	    shift 2
        ;;

        --replace-string)
	    if test $# -lt 3; then echo "[ERROR]: --replace-string: not enough arguments."; show_help; exit 1; fi;
            replace_string $file $2 $3
	    shift 3
        ;;

	--get-option)
	    if test $# -lt 3; then echo "[ERROR]: --get-option: not enough arguments."; show_help; exit 1; fi;
            get_option $file $2 $3
	    shift 3
	;;

	--set-option)
	    if test $# -lt 4; then echo "[ERROR]: --set-option: not enough arguments."; show_help; exit 1; fi;
	    set_option $file $2 $3 $4
	    shift 4
	;;

	--get-option-multiple)
            if test $# -lt 4; then echo "[ERROR]: --get-option-number: not enough arguments."; show_help; exit 1; fi
            get_option_multiple $file $2 $3 $4
            shift 4	    
	;;

	--set-option-multiple)
            if test $# -lt 6; then echo "[ERROR]: --set-option-number: not enough arguments."; show_help; exit 1; fi
	    set_option_multiple $file $2 $3 $4 $5 $6
	    shift 6
	;;

	--get-option-all)
            if test $# -lt 4; then echo "[ERORR]: --get-option-all: not enough arguments."; show_help; exit 1; fi
	    get_option_all $file $2 $3 $4
	    shift 4
	;;

        --help|-h)
            show_help
            shift 1
        ;;

        *)
            echo "[ERROR]: Unknown option : $1"
            show_help
            exit 1
        ;;

    esac
done

# Done
exit 0
